#!/usr/bin/env python3

import json
import os
import sys
from collections import OrderedDict
import docker
import jinja2

class VrTopo:
    """ vrnetlab topo builder
    """
    def __init__(self, config):
        self.routers = {}
        self.links = []
        self.fullmeshes = {}
        self.hubs = {}
        if 'routers' in config:
            self.routers = config['routers']

        # sanity checking - use a YANG model and pyang to validate input?
        for r, val in self.routers.items():
            if 'type' not in val:
                raise ValueError("'type' is not defined for router %s" % r)
            if val['type'] not in ('dummy', 'xcon', 'bgp', 'xrv', 'xrv9k', 'vmx', 'sros', 'csr', 'vqfx', 'vrp'):
                raise ValueError("Unknown type %s for router %s" % (val['type'], r))

        # expand p2p links
        links = []
        if 'p2p' in config:
            for router in sorted(config['p2p']):
                neighbors = config['p2p'][router]
                for neighbor in neighbors:
                    links.append({ 'left': { 'router': router }, 'right': {
                        'router': neighbor }})

        # expand fullmesh into links
        if 'fullmeshes' in config:
            for name in sorted(config['fullmeshes']):
                val = config['fullmeshes'][name]
                fmlinks = self.expand_fullmesh(val)
                links.extend(fmlinks)

        self.links = self.assign_interfaces(links)

        self.links_by_nodes = OrderedDict()
        for l in self.links:
            for (link, a, b) in ((l, 'left', 'right'), (l, 'right', 'left')):
                if link[a]['router'] not in self.links_by_nodes:
                    self.links_by_nodes[link[a]['router']] = OrderedDict()
                spec = {'our_interface': link[a]['interface'],
                        'their_interface': link[b]['interface'],
                        'our_numeric': link[a]['numeric'],
                        'their_numeric': link[b]['numeric']}
                if link[b]['router'] not in self.links_by_nodes[link[a]['router']]:
                    self.links_by_nodes[link[a]['router']][link[b]['router']] = []
                self.links_by_nodes[link[a]['router']][link[b]['router']].append(spec)

        for router in sorted(self.routers):
            val = self.routers[router]
            if 'interfaces' in val:
                for num_id in val['interfaces']:
                    val['interfaces'][num_id] = self.intf_num_to_name(router, num_id)

        if 'hubs' in config:
            for hub in sorted(config['hubs']):
                self.hubs[hub] = []
                for router in config['hubs'][hub]:
                    ep = {
                        'router': router,
                        'numeric': self.get_interface(router)
                    }
                    ep['interface'] = self.intf_num_to_name(router, ep['numeric'])
                    self.hubs[hub].append(ep)



    def expand_fullmesh(self, routers):
        """ Flatten a full-mesh into a list of links

            Links are considered bi-directional, so you will only see a link A->B
            and not a B->A.
        """
        pairs = {}
        for a in sorted(routers):
            for b in sorted(routers):
                left = min(a, b)
                right = max(a, b)

                if left == right: # don't create link to ourself
                    continue

                if left not in pairs:
                    pairs[left] = {}
                pairs[left][right] = 1

        links = []
        for a in sorted(pairs):
            for b in sorted(pairs[a]):
                links.append({'left': { 'router': a }, 'right': { 'router': b }})

        return links


    def assign_interfaces(self, links):
        """ Assign numeric interfaces to links
        """
        # assign interfaces to links
        for link in links:
            left = link['left']
            left['numeric'] = self.get_interface(left['router'])
            left['interface'] = self.intf_num_to_name(left['router'], left['numeric'])

            right = link['right']
            right['numeric'] = self.get_interface(right['router'])
            right['interface'] = self.intf_num_to_name(right['router'], right['numeric'])

        return links


    def intf_num_to_name(self, router, interface):
        """ Map numeric ID to interface name
        """
        r = self.routers[router]
        if r['type'] == 'xrv' or r['type'] == 'xrv9k':
            return "GigabitEthernet0/0/0/%d" % (interface-1)
        elif r['type'] == 'vmx':
            return "ge-0/0/%d" % (interface-1)
        elif r['type'] == 'sros':
            return "{}/1/{}".format(1+int((interface-1)/6), 1+(interface-1)%6)
        elif r['type'] == 'bgp':
            return "tap%d" % (interface-1)
        elif r['type'] == 'csr':
            return "GigabitEthernet%d" % (interface+1)
        elif r['type'] == 'vqfx':
            return "xe-0/0/%d" % (interface-1)
        elif r['type'] == 'vrp':
            return "GigabitEthernet4/0/%d" % (interface)

        return None


    def get_interface(self, router):
        """ Return next available interface
        """
        if router not in self.routers:
            raise ValueError("Router %s is not defined in config" % router)
        if 'interfaces' not in self.routers[router]:
            self.routers[router]['interfaces'] = {}
        intfs = self.routers[router]['interfaces']

        i = 1
        for intf in range(len(intfs)):
            if i not in intfs:
                break
            i += 1

        intfs[i] = None

        return i


    def output(self, output_format='json'):
        """ Output the resulting topology in given format

            output_format can only be json for now
        """
        output = {
                'routers': self.routers,
                'links': self.links,
                'links_by_nodes': self.links_by_nodes,
                'hubs': self.hubs
            }

        if output_format == 'json':
            return json.dumps(output, sort_keys=True, indent=4)
        else:
            raise ValueError("Invalid output format")


def create_network_api(client, name):
    network = client.networks.create(name)
    return(network)


def run_container_api(client, image, name, run_args, links=None, network=None):
    if not network:
        network = 'bridge'
    # tmpfs mount /tmp inside the containers. for me this was required
    # on debian, otherwise the cpu load would spike to unreasonable levels
    # when vr-bgp was trying to read/write to the sqlite db(at least that
    # is my working theory). figure it cant hurt to do it by default.
    container = client.containers.run(image, command=run_args, detach=True, privileged=True, name=name, links=links, tmpfs=['/tmp'], network=network)
    return(container)


def stop_container_api(client, name):
    container = client.containers.get(name)
    container.stop()
    client.close()


def remove_container_api(client, name):
    container = client.containers.get(name)
    container.remove()
<<<<<<< HEAD


def get_container_health_api(client, name):
    container = client.containers.get(name)
    health = container.attrs['State']['Health']['Status']
    return(health)


def get_container_state_api(client, name):
    container = client.containers.get(name)
    state = container.attrs['State']['Status']
    return(state)


def get_network_api(client, name):
    network = client.networks.get(name)
    return(network)


=======


def get_container_health_api(client, name):
    container = client.containers.get(name)
    health = container.attrs['State']['Health']['Status']
    return(health)


def get_container_state_api(client, name):
    container = client.containers.get(name)
    state = container.attrs['State']['Status']
    return(state)


def get_network_api(client, name):
    network = client.networks.get(name)
    return(network)


>>>>>>> 112c33b9b2e042652896f51ea05faf9c89382649
def run_topology_api(config, url, with_trace=False):

    # set up connection to docker api
    try:
        client = docker.DockerClient(base_url=url)
    except docker.errors.APIError:
        print("ERROR: {}".format(docker.errors.APIError))
        sys.exit(1)

    if 'routers' not in config:
        print("No routers in config")
        sys.exit(1)

    trace = ''
    if with_trace:
        trace = '--trace'

    docker_networks = list(set([r['docker_network'] for r in config['routers'].values() if 'docker_network' in r]))
    if len(docker_networks) > 1:
        print("At most 1 docker network allowed")
        sys.exit(1)
    try:
        network = get_network_api(client, docker_networks[0])
        docker_network = docker_networks[0]
    except docker.errors.NotFound:
        try:
            docker_network = docker_networks[0]
            create_network_api(client, docker_network)
        except docker.errors.APIError:
            print("ERROR: failed to create network {} : {}".format(docker_networks[0], docker.errors.APIError))
            sys.exit(1)
    except:
        docker_network = None

    docker_registry = ""
    if os.getenv("DOCKER_REGISTRY"):
        docker_registry = os.getenv("DOCKER_REGISTRY") + "/"
    for router in sorted(config['routers']):
        val = config['routers'][router]
        if val["type"] == "dummy":
            continue

        name = "%s%s" % (args.prefix, router)
        image = "%svr-%s:%s" % (docker_registry, val["type"], val["version"])

        api_cmd = []
        if trace:
            api_cmd.append(trace)
        if 'run_args' in val:
            api_cmd.extend(val["run_args"].split())

        state_output = ''
        health_output = ''
        try:
            state_output = get_container_state_api(client, name)
            try:
                health_output = get_container_health_api(client, name)
            except KeyboardInterrupt:
                raise
            # not all containers report health, so pass on exceptions
            except:
                pass
            print("Container(%s) already running. State: %s Health: %s" % (name, state_output, health_output.strip()))
        except KeyboardInterrupt:
            raise
        except docker.errors.NotFound:
            print("Starting container(%s)" % name)
            run_container_api(client, image, name, api_cmd, None, docker_network)

    if 'links' in config:
        name = "%svr-xcon" % args.prefix
        image = "%s%s" % (docker_registry, 'vr-xcon')

        links = []
        api_cmd = []
        for vr in sorted(config['routers']):
            links.append((args.prefix + vr, args.prefix + vr))
        api_cmd.append("--p2p")
        api_cmd.extend(["%s%s/%s--%s%s/%s" % (args.prefix, link["left"]["router"],
                                           link["left"]["numeric"],
                                           args.prefix,
                                           link["right"]["router"],
                                           link["right"]["numeric"]) for link in config['links']])
        state_output = ''
        health_output = ''
        try:
            state_output = get_container_state_api(client, name)
            try:
                health_output = get_container_health_api(client, name)
            except KeyboardInterrupt:
                raise
            # not all containers report health, so pass on exception
            except:
                pass
            print("Container(%s) already running. State: %s Health: %s" % (name, state_output, health_output.strip()))
        except KeyboardInterrupt:
            raise
        except docker.errors.NotFound:
            print("Starting container(%s)" % name)
            run_container_api(client, image, name, api_cmd, links, docker_network)


    # close connection to docker api
    try:
        client.close()
    except docker.errors.APIError:
        print("ERROR: {}".format(docker.errors.APIError))
        sys.exit(1)


def stop_topology_api(config, url):

    # set up connection to docker api
    try:
        client = docker.DockerClient(base_url=url)
    except docker.errors.APIError:
        print("ERROR: {}".format(docker.errors.APIError))
        sys.exit(1)

    if 'routers' not in config:
        print("No routers in config")
        sys.exit(1)

    for router in sorted(config['routers']):
        name = "%s%s" % (args.prefix, router)
        try:
            stop_container_api(client, name)
            print("Stopped container(%s)" % name)
        except KeyboardInterrupt:
            raise
        except:
            print("Container(%s) is not running" % name)
        try:
            remove_container_api(client, name)
            print("Removed container(%s)" % name)
        except KeyboardInterrupt:
            raise
        except:
            print("Container(%s) already removed" % name)
<<<<<<< HEAD
=======

    if 'links' in config:
        name = "%svr-xcon" % args.prefix
        try:
            stop_container_api(client, name)
            print("Stopped container(%s)" % name)
        except KeyboardInterrupt:
            raise
        except:
            print("Container(%s) is not running" % name)
        try:
            remove_container_api(client, name)
            print("Removed container(%s)" % name)
        except KeyboardInterrupt:
            raise
        except:
            print("Container(%s) already removed" % name)

    # close connection to docker api
    try:
        client.close()
    except docker.errors.APIError:
        print("ERROR: {}".format(docker.errors.APIError))
        sys.exit(1)
>>>>>>> 112c33b9b2e042652896f51ea05faf9c89382649

    if 'links' in config:
        name = "%svr-xcon" % args.prefix
        try:
            stop_container_api(client, name)
            print("Stopped container(%s)" % name)
        except KeyboardInterrupt:
            raise
        except:
            print("Container(%s) is not running" % name)
        try:
            remove_container_api(client, name)
            print("Removed container(%s)" % name)
        except KeyboardInterrupt:
            raise
        except:
            print("Container(%s) already removed" % name)

    # close connection to docker api
    try:
        client.close()
    except docker.errors.APIError:
        print("ERROR: {}".format(docker.errors.APIError))
        sys.exit(1)

    if 'hubs' in config:
        for hub, eps in config['hubs'].items():
            name = "{}vr-xcon-hub-{}".format(args.prefix, hub)
            cmd = ["docker", "run", "--privileged", "-d", "--name", name]

            if docker_network:
                cmd.extend(["--network", docker_network])
            else:
                for vr in sorted(config['routers']):
                    cmd.extend(["--link", "%s%s:%s%s" % (args.prefix, vr, args.prefix, vr)])
            cmd.append(docker_registry + "vr-xcon")
            cmd.append("--hub")
            cmd.extend(["%s%s/%s" % (args.prefix, ep["router"], ep["numeric"]) for ep in eps])
            run_command(cmd, dry_run)


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--build", help="Build topology from config")
    parser.add_argument("--run", help="Run topology")
    parser.add_argument("--stop", help="stop and clean up topology")
    parser.add_argument("--api", help="docker API url. default is 'unix://var/run/docker.sock'", default='unix://var/run/docker.sock')
    parser.add_argument("--prefix", default='', help="docker container name prefix")
    parser.add_argument("--template", nargs=2, help="produce output based on topology information and a template")
    parser.add_argument("--variable", action='append', help="store variables")
    parser.add_argument("--with-trace", action='store_true', help="run virtual routers with --trace")
    args = parser.parse_args()

    if args.prefix and not (args.run or args.stop):
        print("ERROR: --prefix is only relevant with --run and --stop")
        sys.exit(1)

    if args.build:
        input_file = open(args.build, "r")
        config = json.loads(input_file.read(), object_pairs_hook=OrderedDict)
        input_file.close()
        try:
            vt = VrTopo(config)
        except Exception as exc:
            print("ERROR:", exc)
            sys.exit(1)
        print(vt.output())

    if args.run:
        input_file = open(args.run, "r")
        config = json.loads(input_file.read(), object_pairs_hook=OrderedDict)
        input_file.close()
        run_topology_api(config, args.api, args.with_trace)

    if args.stop:
        input_file = open(args.stop, "r")
        config = json.loads(input_file.read())
        input_file.close()
<<<<<<< HEAD
=======
        run_topology_api(config, args.api, args.with_trace)

    if args.stop:
        input_file = open(args.stop, "r")
        config = json.loads(input_file.read())
        input_file.close()
>>>>>>> 112c33b9b2e042652896f51ea05faf9c89382649
        stop_topology_api(config, args.api)

    if args.template:
        input_file = open(args.template[0], "r")
        config = json.loads(input_file.read(), object_pairs_hook=OrderedDict)
        input_file.close()

        vs = {}
        if args.variable:
            for var in args.variable:
                key,value = var.split("=", 2)
                vs[key] = value

        env = jinja2.Environment(loader=jinja2.FileSystemLoader(['./']))
        template = env.get_template(args.template[1])
        print(template.render(config=config, vars=vs))
